# 内存管理基础

- [内存管理基础](#内存管理基础)
  - [常见内存管理的方法](#常见内存管理的方法)
    - [C 风格的内存管理](#c-风格的内存管理)
    - [池式内存管理](#池式内存管理)
    - [引用计数](#引用计数)
    - [垃圾回收](#垃圾回收)
  - [内存管理器的设计目标](#内存管理器的设计目标)
  - [Ptmalloc 内存管理概述](#ptmalloc-内存管理概述)
    - [Ptmalloc 的设计假设](#ptmalloc-的设计假设)

## 常见内存管理的方法

### C 风格的内存管理

主要通过 malloc 与 free 函数，主要通过 brk 或者 mmap 来对进程添加额外的虚拟内存。

- 优点：灵活、适应性强、速度快。
- 缺点：对于大块的内存释放，可能由于再等待其中某一小块内存而被缓存。内存的生存周期也不容易管理。

### 池式内存管理

内存池是一种半内存管理方法。内存池帮助某些程序进行自动内存管理，这些程序会经历一些特定的阶段，而且每个阶段中都有分配给进程的特定阶段的内存。

- 优点：应用程序可以简单地管理内存。内存分配和回收更快，因为每次都是在一个池中完成的。可以预先分配错误处理池。有非常易于使用的标准实现。
- 缺点：内存池只适用于操作可以分阶段的程序。不能与三方库很好的合作。如果程序的结构发生变化需要修改内存池。需要用户管理内存。

### 引用计数

在引用计数中，所有共享的数据结构都有一个域来包含当前活动“引用”结构的次数。当计数清 0 释放内存。

- 优点：实现简单。易于使用。
- 缺点：需要多余缓存引用结构。异常处理不友好。引用结构存放位置影响 CPU 读取数据。

### 垃圾回收

全自动地检测并移除不再使用的数据对象。垃圾收集器通常会在当可用内存减少到少于一个具体的阈值时运行。以程序的栈、全局变量、寄存器出发追踪这些数据指向的每一块内存，而没有被这些数据指向的则会被回收。

- 优点：简单、易用，不宜出错。
- 缺点：效率低，用户没法指定释放内存，出错后调试困难，如果没有将内存引用置为 NULL，依旧会有内存泄漏的风险。

## 内存管理器的设计目标

1. 兼容性。
2. 可移植性。
3. 内存管理消耗的内存要小。
4. 速度要快。
5. 便于调试。
6. 最大化局部性：尽量保持访问内存的连续性，便于 CPU Cache 缓存。
7. 方便的参数配置。
8. 默认配置的适应性要好。

## Ptmalloc 内存管理概述

Ptmalloc 对比老版本 malloc 支持了多线程的支持。分配置处在用户程序和内核之间，它响应用户的分配请求，向操作系统申请内存，然后将其返回给用户程序，为了保持高效的分配，分配器一般都会预先分配一块大于用户请求的内存，并通过某种算法管理这块内存。来满足用户的内存分配要求，用户释放掉的内存也并不是立即就返回给操作系统，相反，分配器会管理这些被释放掉的空闲空间，以应对用户以后的内存分配要求。

### Ptmalloc 的设计假设

- [参考文章-系统调用与内存管理](https://blog.csdn.net/apollon_krj/article/details/54565768)

1. ​​具有长生命周期的大内存分配使用 mmap。
2. 特别大的内存分配总是使用 mmap.
3. 具有短生命周期的内存分配使用 sbrk。
4. 尽量只缓存临时使用的空闲小内存块，当大内存块或者是生命周期较长的大内存块在释放时都直接归还给操作系统。
5. 需要长期存储的程序不合适用 ptmalloc 来管理。
6. 对空闲的小内存块只会在 malloc 和 free 的时候进行合并。free 时空闲内存块可能放入内存池中，而不是立即归还给操作系统。
7. 为了支持多线程，多个线程可以同一个分配区中分配内存，ptmalloc 假设线程 A 释放掉一块内存后，线程 B 申请类似大小的内存，但是 A 释放的内存跟 B 需要的内存不一定完全相等。
